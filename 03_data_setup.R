##############################################################################################################
## Project: Long COVID
## Code author(s): karen.jeffrey@ed.ac.uk
## Description: 03_data_setup - Links testing and covariate data for individuals included in the analysis.
## Also creates study start and endpoints (based on test dates) and censors as needed. 
## Exports prepared data to: "/conf/EAVE/GPanalysis/analyses/long_covid/data/LongCOVID_linked.rds"
##############################################################################################################

# 0. Set-up ------

# Clear environment 
rm(list=ls())

# Libraries
library(tidyverse)
library(lubridate)

# 1. Prepare basic GP data ----
# Read in GP data supplied by Albasoft and set extract date
GP_raw <- readRDS("/conf/EAVE/GPanalysis/analyses/long_covid/data/longcovid_261022.rds") # full cohort, extracted 20/10/22 (despite being dated 26/10/22)
extract <- date("2022-10-20")

# Get unique EAVE_LINKNOs and clean up (N = 6,946,072 --> 5,825,144)
df <- GP_raw %>% 
  distinct(EAVE_LINKNO, .keep_all = T) %>%  
  mutate(age = as.numeric(chi_age),
         sex = ifelse(chi_sex == "F", "F", ifelse(chi_sex == "M", "M", NA)),
         tes_res = ifelse(is.na(test_result), "NEVER TESTED", ifelse(test_result == "NEGATIVE", "NEGATIVE", "POSITIVE")),
         tes_dat = ymd(date_ecoss_specimen),
         ## Recode age 18-79, then two-year bands from ages 80-89, five-year bands for 90-99, and one final band for 100+
         age = case_when(age >= 95 & age <= 99 ~ 97,
                         age >= 90 & age <= 94 ~ 92,
                         age >= 80 & age <= 89 ~ trunc(age/2)*2,
                         TRUE ~ age),
         age = as.numeric(age),
         ## 10-year age bands (for balance checks, desriptive statistics)
         age_10 = cut(age, breaks = c(seq(18, 98, by=10), 150), right=F)) %>% 
  # Keep over 18s
  filter(age >= 18 & age <= 110) %>% # to remove spuriously high age data
  # Select variables of interst
  select(EAVE_LINKNO, age, age_10, sex, tes_res, tes_dat)

# Remove GP_raw 
rm(GP_raw)


# 1.0 Clean up EAVE_LINKNOs ----
## Set study start
start <- ymd("2020-03-01")
end <- ymd("2022-10-20")

## Read in EAVE_LINKNO refresh file from PHS
EAVE_raw <- readRDS("/conf/EAVE/GPanalysis/data/EAVE_LINKNO_refresh.rds")

## Keep individuals who:
EAVE <- EAVE_raw %>% # 6,988,571
  ## have a validated CHI number
  filter(unvalidatedCHI_flag != 1) %>% #6,978,344
  ## were alive at the start of the study
  filter(is.na(NRS.Date.Death) | NRS.Date.Death > start) %>% #6,972,704
  ## did not transfer in after the study start date
  filter(is.na(DATE_TRANSFER_IN) | DATE_TRANSFER_IN < start) %>%  #6,476,394
  ## did not transfer out before or during the study period
  filter(is.na(DATE_TRANSFER_OUT) | DATE_TRANSFER_OUT > end) # 6,143,859
  
## Check whether to match to df on new or old EAVE_LINKNOs
table(df$EAVE_LINKNO %in% EAVE$EAVE_LINKNO) # 5,133,657
table(df$EAVE_LINKNO %in% EAVE$EAVE_LINKNO_old) # 5,142,872 --> suggests use EAVE_LINKNO_old

## Check EAVE_LINKNO_old captures everyone in EAVE_LINKNO
table((df$EAVE_LINKNO %in% EAVE$EAVE_LINKNO) %in% (df$EAVE_LINKNO %in% EAVE$EAVE_LINKNO_old)) # 100% == True --> match to EAVE_LINKNO_old

## Use cleaned up EAVE_LINKNOs to select EAVE_LINKNOs in df
df <- df %>% 
  filter(EAVE_LINKNO %in% EAVE$EAVE_LINKNO_old) # 5,142,872

## Update EAVE_LINKNOs to be the new EAVE_LINKNOs (generated by PHS)
### Remove duplicates from EAVE
EAVE <- EAVE %>% 
  distinct(EAVE_LINKNO_old, .keep_all = T) %>% 
  distinct(EAVE_LINKNO, .keep_all = T) 

### Update EAVE_LINKNO and keep the old EAVE_LINKNO
df <- df %>% 
  left_join(select(EAVE, "EAVE_LINKNO" = EAVE_LINKNO_old, "EAVE_LINKNO_new" = EAVE_LINKNO), by = "EAVE_LINKNO") %>% 
  mutate("old_EAVE_LINKNO" = EAVE_LINKNO, # keep old EAVE_LINKNO
         "EAVE_LINKNO" = EAVE_LINKNO_new) %>% 
  select(-EAVE_LINKNO_new) %>% # 5,142,872
  # Remove individuals who have an old EAVE_LINKNO but no new EAVE_LINKNO
  filter(!is.na(EAVE_LINKNO)) # 5,133,660

rm(EAVE_raw, EAVE)


# 1.1 Add new positive tests (among controls) recorded after extract of CHI numbers and before GP data extract (N = 2,443) ----
## Check max test date in GP data
GP_max_date <- max(df$tes_dat, na.rm=T) # 29/8/22

## Read in testing data
testing_raw <- readRDS("/conf/EAVE/GPanalysis/data/CDW_full.rds")

## Select first positive tests after extract of CHI numbers and before GP data extract
new_pos <- testing_raw %>%
  select(EAVE_LINKNO, 
         tes_dat = date_ecoss_specimen, 
         tes_res = test_result) %>% 
  ## Only check individuals in df who are not already identified as having tested positive
  filter(EAVE_LINKNO %in% df$EAVE_LINKNO[df$tes_res!="POSITIVE"]) %>%
  ## Only capture those who test positive after the GP extract request was submitted, and > 28 days before the extract was done (so there's follow-up to analyse)
  filter(tes_res == "POSITIVE") %>% 
  filter(tes_dat > GP_max_date & tes_dat < (extract-28)) %>% 
  ## Keep each individual's first new positive test only
  arrange(tes_dat) %>% 
  filter(!duplicated(EAVE_LINKNO)) %>% 
  mutate(new_pos = date(tes_dat)) %>% 
  select(EAVE_LINKNO, new_pos) 

## Update df with new test results
df <- df %>% 
  left_join(new_pos, by= "EAVE_LINKNO") %>% 
  mutate(tes_res = ifelse(is.na(new_pos), tes_res, "POSITIVE"),
         new_pos = ymd(new_pos),
         tes_dat = ifelse(is.na(new_pos), tes_dat, new_pos),
         tes_dat = as.Date(tes_dat, origin = "1970-01-01")) %>% 
  select(-new_pos)

## Remove files 
rm(new_pos, GP_max_date) # keep testing_raw for later


# 1.2 Create a second entry for individuals who tested negative >28 days before testing positive ----
# Do this so individuals who test negative and then test positive later can be used as controls in matched analysis (until they test positive)
# NB these individuals will be censored when they test positive (which is why only those with >28 days of follow up are included)

## Save positive test dates in a new var (so that they can be written over below, but preserved for censoring in 04_propensity_score_matching)
df <- df %>% 
  mutate(pos_dat = ifelse(tes_res=="POSITIVE", tes_dat, NA),
         pos_dat = as.Date(pos_dat, origin = "1970-01-01"))

## Get testing data for individuals who have tested positive
pos_tests <- testing_raw[testing_raw$EAVE_LINKNO %in% df$EAVE_LINKNO[df$tes_res == "POSITIVE"],]

## Get first negative test date for individuals who later test positive
neg_tests <- pos_tests %>% 
  filter(test_result == "NEGATIVE") %>% 
  mutate(date_ecoss_specimen = date(date_ecoss_specimen)) %>% 
  select(EAVE_LINKNO, date_ecoss_specimen) %>% 
  group_by(EAVE_LINKNO) %>% 
  arrange(date_ecoss_specimen) %>% 
  slice(1)

## Get individuals whose first negative test was >28 days before their positive test and identify those entries as 
## duplicate entries to be used as controls
df2 <- df %>% 
  filter(tes_res=="POSITIVE") %>% 
  left_join(neg_tests, by = "EAVE_LINKNO") %>% 
  filter(!is.na(date_ecoss_specimen)) %>%
  filter(tes_dat > date(date_ecoss_specimen + 28)) %>% # keep positive tests more than 28 days after negative test
  mutate(tes_res = "NEGATIVE",
         tes_dat = date_ecoss_specimen,
         pos_control = 1) %>% 
  select(-date_ecoss_specimen)

## Identify those in already in df as not being positive controls
df$pos_control <- 0

## Join to GP
df <- rbind(df, df2) 

## Remove files
rm(df2, pos_tests, neg_tests) # Keep testing_raw for 1.3 


# 1.3 Add first test date ----
## Add this so we know whether to treat positive cases being used as controls in time-varying propensity score matching as negative 
##controls for that month (i.e. because they have not yet tested positive during the month under consideration), or as not yet tested
first_tes <- testing_raw %>% 
  mutate(date_ecoss_specimen = date(date_ecoss_specimen)) %>% 
  select(EAVE_LINKNO, date_ecoss_specimen) %>% 
  arrange(date_ecoss_specimen) %>% 
  group_by(EAVE_LINKNO) %>% 
  slice(1) %>% 
  rename(first_tes = date_ecoss_specimen)

df <- df %>% 
  left_join(first_tes, by = "EAVE_LINKNO")
  
## Remove files
rm(first_tes) # Keep testing_raw for later


# 2. LINK DATA -----

# 2.1 Weights -----
## Scripts are written to use weights, but after EAVE_LINKNO refresh, weighting is no longer necessary --> set all weights to 1
df$eave_weight <- 1


# 2.2 Deaths -----
## Read in NRS deaths data
deaths_raw <- readRDS("/conf/EAVE/GPanalysis/data/all_deaths.rds")

## Get death dates 
death_dats <- deaths_raw %>% 
  select(EAVE_LINKNO,
         dea_dat = NRS.Date.Death) %>% 
  filter(!duplicated(EAVE_LINKNO)) %>% 
  filter(!is.na(dea_dat)) %>%
  select(EAVE_LINKNO, dea_dat)

## Join to df and remove individuals who died 
df <- df %>% 
  left_join(death_dats, by = "EAVE_LINKNO") %>% 
  filter(is.na(dea_dat) | dea_dat >= "2020-02-29") %>% # Filter out those who died before the start of our analysis (01/02/20) + 28 days
  filter(is.na(dea_dat) | is.na(tes_dat) | dea_dat >= (tes_dat + 28)) # Filter out those who died before tes_dat + 28 days 

## Remove files
rm(deaths_raw, death_dats)


# 2.3 Geographic ------------
## Read in geogrpahic data
demog_raw <- readRDS("/conf/EAVE/GPanalysis/outputs/temp/Cohort_Demog_Endpoints_Times2021-07-28.rds")

## Select columns of interest
demog <- demog_raw %>%
  select(EAVE_LINKNO,
         simd = simd2020_sc_quintile, 
         ur6_lab = ur6_2016_name, 
         dat_zon = DataZone) # used to derive Council

## Link to df and impute missing values
df <- df %>% 
  left_join(demog, by= c("old_EAVE_LINKNO" = "EAVE_LINKNO")) %>% 
  mutate(simd = if_else(is.na(simd),"Unknown", as.character(simd)),
         simd = if_else(simd == "NA","Unknown", as.character(simd)),
         ur6_lab = if_else(is.na(ur6_lab),"Unknown", ur6_lab)) 


## Check: do the same people have missing simd and ur6_lab? Answer: Yes
table(df$EAVE_LINKNO[df$simd == "Unknown"] == df$EAVE_LINKNO[df$ur6_lab == "Unknown"])

## Get EAVE_LINKNOs with missing geographic data
geo_missing <- df$EAVE_LINKNO[df$simd == "Unknown"]

geo_missing <- unique(geo_missing)

## Get simd & ur6_lab from testing file for individuals in geo_missing
geo_fill <- testing_raw %>% 
  select(EAVE_LINKNO, simd2 = simd2020v2_sc_quintile, ur6_lab2 = ur6_2020) %>% 
  filter(!is.na(simd2)) %>% 
  filter(EAVE_LINKNO %in% geo_missing) %>% 
  distinct(EAVE_LINKNO, .keep_all = T)

## Recode ur6_lab2 and simd to match df
library(plyr)
geo_fill$ur6_lab2 <- mapvalues(geo_fill$ur6_lab2, from = c(1:6), to = c("1 Large Urban Areas", 
                                                                        "2 Other Urban Areas", 
                                                                        "3 Accessible Small Towns", 
                                                                        "4 Remote Small Towns",
                                                                        "5 Accessible Rural", 
                                                                        "6 Remote Rural"))


geo_fill$simd2 <- mapvalues(geo_fill$simd2, from = c(1:5), to = c("1 - High", "2", "3", "4", "5-Low"))
detach(package:plyr,unload=TRUE)

## Fill in missing geographic values in df
df <- df %>% 
  left_join(geo_fill, by = "EAVE_LINKNO") %>% 
  mutate(simd = ifelse(simd == "Unknown", simd2, simd),
         simd = ifelse(is.na(simd), "Unknown", simd),
         ur6_lab = ifelse(ur6_lab == "Unknown", ur6_lab2, ur6_lab),
         ur6_lab = ifelse(is.na(ur6_lab), "Unknown", ur6_lab)) %>% 
  select(-c(simd2, ur6_lab2))

rm(geo_missing, geo_fill)

## Get EAVE_LINKNOs with missing datazones
missing_dz <- df$EAVE_LINKNO[df$dat_zon=="Unknown"]

## Get dat_zon from testing file for individuals in geo_missing
dz_fill <- testing_raw %>% 
  select(EAVE_LINKNO, dat_zon2 = datazone2011) %>% 
  filter(EAVE_LINKNO %in% missing_dz) %>% 
  filter(!is.na(dat_zon2)) %>% 
  distinct(EAVE_LINKNO, .keep_all = T)

df <- df %>% 
  left_join(dz_fill, by = "EAVE_LINKNO") %>% 
  mutate(dat_zon = ifelse(dat_zon == "Unknown", dat_zon2, dat_zon),
         dat_zon = ifelse(is.na(dat_zon), "Unknown", dat_zon)) %>% 
  select(-dat_zon2)

rm(missing_dz, dz_fill)

## Geography lookup
datazones_raw <- read_csv("/conf/EAVE/GPanalysis/data/restored/map_files/Datazone2011Lookup.csv") 

## Select columns of interest
datazones<- datazones_raw %>%  
  select(dat_zon = DataZone, 
         council = Council, 
         hb = HB)

## Link to df and impute missing values
df <- df %>% 
  left_join(datazones, by = "dat_zon")%>% 
  mutate(council = if_else(is.na(council),"Unknown", council),
         hb = if_else(is.na(hb),"Unknown", hb)) %>% 
  select(-dat_zon)

## Remove files
rm(demog, demog_raw, datazones_raw, datazones)



## 2.4 Q-COVID: Type of residence, BMI, risk factors -------
Q_raw <- readRDS("/conf/EAVE/GPanalysis/progs/CR/Vaccine/output/temp/Qcovid.rds") # use this version due to problem with diabetes codes in later version

## Select columns of interest
Q <- Q_raw %>%
  select(c(EAVE_LINKNO, Q_DIAG_AF:Q_DIAG_VTE, Q_DIAG_CKD_LEVEL, n_risk_gps),
         hom_typ = Q_HOME_CAT, # type of residence
         bmi = Q_BMI) # risk groups


## Link to df, clean up variables
df <- df %>% 
  left_join(Q, by= c("old_EAVE_LINKNO" = "EAVE_LINKNO")) %>%   
  mutate(hom_typ = ifelse(is.na(hom_typ), "Unknown", hom_typ),
         bmi = as.numeric(bmi), 
         bmi = ifelse(bmi > 5 & bmi < 80, bmi, NA)) %>% # cleaning (extreme values are likely errors)
  mutate_at(vars(Q_DIAG_AF:Q_DIAG_CKD_LEVEL), ~replace_na(.,0)) %>% 
  mutate(Q_DIAG_CKD_LEVEL = ifelse(Q_DIAG_CKD_LEVEL > 0, 1, 0), # binarise
         n_risk_gps = ifelse(is.na(n_risk_gps), 0, n_risk_gps))

## Impute missing bmi using simd, sex and age 
### Make simd a factor
df$simd <- as.factor(df$simd)

### Create df without missing values to use in modelling
mod_dat <- df %>% 
  select(bmi, age, sex, simd) %>% 
  filter(!is.na(bmi),
         simd != "Unknown")

### Model
bmi_mod <- lm(bmi ~ age + sex + simd, data=mod_dat)

### Stepwise regression
fit <- step(bmi_mod, direction="both", k=2)

### Impute where bmi == na but not where simd is unknown (because simd used for imputation)
mask <- is.na(df$bmi) & df$simd != "Unknown"
df$bmi_imp[mask] <- predict(fit, newdata = subset(df, mask))
df$bmi_imp <- ifelse(is.na(df$bmi_imp), df$bmi, df$bmi_imp)

### Mean impute remaining missing values
df$bmi_imp <- ifelse(is.na(df$bmi_imp), mean(df$bmi_imp, na.rm = T), df$bmi_imp)

## Remove files
rm(Q, Q_raw, bmi_mod, fit, mod_dat, mask)


# 2.5 Vulnerable individuals (shielding. immuno compromised) --------
vuln_raw <- readRDS("/conf/EAVE/GPanalysis/data/cleaned_data/C19vaccine_dvprod_cleaned_incl_cohorts_20220926.rds") # NB data ceased being compiled beyond 26/09/22

vuln <- vuln_raw %>% 
  # Remove duplicates
  filter(!duplicated(EAVE_LINKNO)) %>% 
  # Select columns of interest
  select(EAVE_LINKNO, shielding, immuno_supp)

## Link to df and clean up
df <- df %>% 
  left_join(vuln, by = c("old_EAVE_LINKNO" = "EAVE_LINKNO")) %>% 
  mutate(shielding = ifelse(is.na(shielding), 0L, shielding),
         immuno_supp = ifelse(is.na(immuno_supp), 0L, immuno_supp))

## Remove files
rm(vuln, vuln_raw)


# 2.6 Household data ----
## Read in household data 
hhold_raw <- readRDS("/conf/EAVE/GPanalysis/outputs/temp/Cohort_Household.rds") 

## Select columns of interest
hhold <- hhold_raw %>% 
  select(EAVE_LINKNO, n_hh) %>% 
  mutate(hhold_n = n_hh) %>%  # No. individuals in the household 
  select(EAVE_LINKNO, hhold_n)

## Join to df
df <- df %>% 
  left_join(hhold, by = c("old_EAVE_LINKNO" = "EAVE_LINKNO")) %>% 
  # Mean impute missing values and create bands - keep non-imputed values too
  mutate(hhold_raw = hhold_n,
         hhold_raw_bands = cut(hhold_raw, breaks=c(0,1,2,5,10,30,100,Inf),
                           labels=c("1", "2", "3-5", "6-10", "11-30", "31-100", "101+")),
         hhold_n = ifelse(is.na(hhold_n), mean(hhold_n, na.rm = T), hhold_n), 
         hhold_bands = cut(hhold_n, breaks=c(0,1,2,5,10,30,100,Inf),
                           labels=c("1", "2", "3-5", "6-10", "11-30", "31-100", "101+")))

## Remove files
rm(hhold_raw, hhold)


# 2.7 Number of tests by tes_dat ----
n_tests <- testing_raw %>%
  select(EAVE_LINKNO, date_ecoss_specimen) %>%
  mutate(date_ecoss_specimen = as_date(date_ecoss_specimen)) %>% 
  distinct(EAVE_LINKNO, date_ecoss_specimen) %>% # So that tests recorded on the same date are treated as a single test
  left_join(select(df, "EAVE_LINKNO", tes_dat), by = "EAVE_LINKNO") %>% 
  filter(date_ecoss_specimen <= tes_dat) %>% 
  select(-tes_dat,
         EAVE_LINKNO, 
         tes_dat = date_ecoss_specimen) %>% 
  mutate(tes_dat = as_date(tes_dat)) %>%  
  add_count(EAVE_LINKNO, name = "tes_n") %>% 
  distinct(EAVE_LINKNO, tes_n)

df <- df %>% 
  left_join(n_tests, by= "EAVE_LINKNO") %>% 
  mutate(tes_n = if_else(is.na(tes_n ), 0L, tes_n), # n_tests = 0 for all those who have never tested
         tes_n = if_else(tes_res == "NEGATIVE", 1L, tes_n)) # n_tests = 1 for all negative cases (tes_dat is their first negative test before any positive test)

## Remove files
rm(n_tests) # Keep testing_raw for 3.2


# 3. Prepare variables used for matching & analysis ----

# 3.1 Set tes_wk, tes_mon, tes_yr and stu_sta, stu_12w, stu_end for all individuals who have a test date ----
# NB All 'never tested' will have these variables imputed later, based on their positive match's test date
df <- df %>% 
  mutate(tes_wk = week(tes_dat), # Week of test
         tes_wk = factor(tes_wk, levels = c(1:52)),
         tes_mon = month(tes_dat), # Month of test
         tes_mon = factor(tes_mon, levels = c(1:12)),
         tes_yr = year(tes_dat), # Year of test
         tes_yr = factor(tes_yr, levels = c(2020:2022)),
         stu_sta = tes_dat + 28, # 4 weeks post-test
         stu_sta = as.Date(stu_sta, origin = "1970-01-01"),
         stu_12w = tes_dat + 84, # 12 weeks post-test
         stu_12w = as.Date(stu_12w, origin = "1970-01-01"),
         stu_end = tes_dat + 182, # 26 weeks post-test (half a year)
         stu_end = as.Date(stu_end, origin = "1970-01-01"))


## Make missing tes_wk = 52 (missing for 30th Dec and 31st Dec)
df$tes_wk <- ifelse(df$tes_res != "NEVER TESTED" & is.na(df$tes_wk), 52, df$tes_wk)


# 3.2 Censor endpoints ----
# NB All 'never tested' will be censored for death or incomplete follow-up later, based on their positive match's test date

# Censor for reinfection i.e. if positive case tests positive again > 42 days after first positive test (to avoid conflating 
# re-infection with long-COVID). PHS advised to use 42 day cut off to account for persistence of viral material 
## Get dates of subsequent positive tests > 42 days after initial positive test
subsequent_pos <- testing_raw %>% 
  filter(test_result == "POSITIVE") %>%
  mutate(date_ecoss_specimen = date(date_ecoss_specimen)) %>% 
  left_join(select(df, EAVE_LINKNO, tes_dat, tes_res), by = "EAVE_LINKNO") %>% 
  filter(tes_res == "POSITIVE") %>% 
  filter(date_ecoss_specimen > (tes_dat + days(42))) %>% 
  arrange(date_ecoss_specimen) %>% 
  group_by(EAVE_LINKNO) %>% 
  slice(1) %>%
  rename(subs_pos = date_ecoss_specimen) %>% 
  select(EAVE_LINKNO, subs_pos)

## Censor
df <- df %>% 
  left_join(subsequent_pos, by = "EAVE_LINKNO") %>%
  mutate(subs_pos = as.Date(subs_pos, origin = "1970-01-01"),
         stu_end = ifelse(is.na(subs_pos), stu_end, ifelse(subs_pos < stu_end, subs_pos, stu_end)),
         stu_end = as.Date(stu_end, origin = "1970-01-01"),
         stu_12w = ifelse(is.na(subs_pos), stu_12w, ifelse(subs_pos < stu_12w, subs_pos, stu_12w)),
         stu_12w = as.Date(stu_12w, origin = "1970-01-01")) %>%
  select(-subs_pos) 

rm(subsequent_pos)


# Censor if negative case tests positive later
## Get dates of first positive test for negative cases that go on to test positive
neg_tests_pos <- df %>% 
  filter(tes_res=="POSITIVE") %>% 
  select(EAVE_LINKNO, tes_dat) %>% 
  rename(first_pos_dat = tes_dat)

censor_neg <- df %>% 
  filter(pos_control == 1) %>% 
  left_join(neg_tests_pos, by = "EAVE_LINKNO") %>% 
  filter(stu_sta < first_pos_dat) %>% # Removes cases that test positive within 28 days of testing negative
  mutate(stu_end = ifelse(first_pos_dat < stu_end, first_pos_dat, stu_end),
         stu_end = as.Date(stu_end, origin = "1970-01-01"),
         stu_12w = ifelse(first_pos_dat < stu_12w, first_pos_dat, stu_12w),
         stu_12w = as.Date(stu_12w, origin = "1970-01-01")) %>% 
  select(-first_pos_dat)

df <- df %>% 
  filter(pos_control == 0)

df <- rbind(df, censor_neg) 

rm(neg_tests_pos, censor_neg, testing_raw)


# Censor if case dies before stu_end (i.e. within 6 months of testing) 
df <- df %>% 
  mutate(dea_dat = date(dea_dat)) %>% 
  filter(is.na(dea_dat) | stu_sta < dea_dat) %>% 
  mutate(stu_end = ifelse(!is.na(dea_dat) & dea_dat <= stu_end, dea_dat, stu_end),
         stu_end = as.Date(stu_end, origin = "1970-01-01"),
         stu_12w = ifelse(!is.na(dea_dat) & dea_dat <= stu_12w, dea_dat, stu_12w),
         stu_12w = as.Date(stu_12w, origin = "1970-01-01"))  



# Censor if case has incomplete follow-up due to testing soon before data extract
df <- df %>% 
  filter(is.na(stu_sta) | stu_sta < extract) %>% 
  mutate(stu_end = ifelse(stu_end > extract, extract, stu_end),
         stu_end = as.Date(stu_end, origin = "1970-01-01"),
         stu_12w = ifelse(stu_12w > extract, extract, stu_12w),
         stu_12w = as.Date(stu_12w, origin = "1970-01-01"))


# Keep cases that have at least one day between stu_sta and stu_12w (so that we have at least 1 day of data to analyse)
# NB the period between stu_sta and stu_12w may be 0 or negative because of censoring
df <- df %>% 
  mutate(follow_up = stu_12w - stu_sta) %>% 
  filter(is.na(follow_up) | follow_up > 1) %>% 
  select(-follow_up)


# 4. Export df -----
## Check for missing values
## Testing data and study dates are missing for 2,122,657 who never tested (as expected)
## Positive test dates are missing for 3,969,032 who never tested positive (as expected)
## Missing values for death date, and versions of BMI and household size that don't include imputed values (as expected)
missing_vals <- colSums(is.na(df))
missing_vals[missing_vals>0]

## Export
saveRDS(df, "/conf/EAVE/GPanalysis/analyses/long_covid/data/LongCOVID_linked.rds", compress = TRUE)

